{"version":3,"sources":["../src/index.ts"],"names":["CDP","Version","writeArchives","__name","testTitlePath","domSnapshots","resourceArchive","chromaticStorybookParams","pageUrl","viewport","outputDir","allSnapshots","Object","fromEntries","map","name","snapshot","index","Buffer","from","JSON","stringify","writeTestResult","titlePath","resourceArchiver","host","port","setupNetworkListener","allowedDomains","webSocketDebuggerUrl","cdp","target","ResourceArchiver","watch","err","console","log","saveArchives","archiveInfo","Promise","resolve","archive","then","prepareArchives","action","payload","onBeforeBrowserLaunch","browser","launchOptions","config","isTextTerminal","hostArg","args","find","arg","startsWith","split","portArg","portString","process","env","ELECTRON_EXTRA_LAUNCH_ARGS","item","Error","parseInt","installPlugin","on"],"mappings":"iFACA,OAAOA,IAAOC,WAAAA,OAAe,2w+CA6B7B,IAAMC,GAAgBC,EAAA,MAAO,CAC3BC,cAAAA,EACAC,aAAAA,EACAC,gBAAAA,EACAC,yBAAAA,EACAC,QAAAA,EACAC,SAAAA,EACAC,UAAAA,CAAS,IACW,CACpB,IAAMC,EAAeC,OAAOC,YAE1BR,EAAaS,IAAI,CAAC,CAAEC,KAAAA,EAAMC,SAAAA,CAAQ,EAAIC,IAAU,CAC9CF,GAAQ,aAAaE,EAAQ,CAAA,GAC7BC,OAAOC,KAAKC,KAAKC,UAAUL,CAAAA,CAAAA,EAC5B,CAAA,EAGH,MAAMM,EACJ,CACEC,UAAWnB,EACXM,UAAAA,EACAF,QAAAA,EACAC,SAAAA,CACF,EACAE,EACAL,EACAC,CAAAA,CAEJ,EA5BsB,iBAkClBiB,EAAqC,KAErCC,GAAO,GACPC,GAAO,EAELC,GAAuBxB,EAAA,MAAO,CAClCyB,eAAAA,CAAc,IAGf,CACC,GAAI,CACF,GAAM,CAAEC,qBAAAA,CAAoB,EAAK,MAAM5B,GAAQ,CAC7CwB,KAAAA,GACAC,KAAAA,EACF,CAAA,EAEMI,EAAM,MAAM9B,GAAI,CACpB+B,OAAQF,CACV,CAAA,EAEKL,IACHA,EAAmB,IAAIQ,EAAiBF,EAAKF,CAAAA,EAC7C,MAAMJ,EAAiBS,MAAK,EAEhC,OAASC,EAAK,CACZC,QAAQC,IAAI,MAAOF,CAAAA,CACrB,CAEA,OAAO,IACT,EAxB6B,wBA0BvBG,GAAelC,EAACmC,GACb,IAAIC,QAASC,GAKXtC,GAAc,CAAE,GAAGoC,EAAahC,gBAAiBkB,EAAiBiB,OAAQ,CAAA,EAAGC,KAAK,IAAA,CACvFF,EAAQ,IAAA,CACV,CAAA,CACF,EATmB,gBAoBRG,GAAkBxC,EAAA,MAAO,CAAEyC,OAAAA,EAAQC,QAAAA,CAAO,IAAc,CACnE,OAAQD,EAAAA,CACN,IAAK,yBACH,OAAOjB,GAAqBkB,CAAAA,EAC9B,IAAK,gBACH,OAAOR,GAAaQ,CAAAA,EACtB,QACE,OAAO,IACX,CACF,EAT+B,mBAYlBC,GAAwB3C,EAAA,CAGnC4C,EACAC,EACAC,IAAAA,CAGA,GAAI,CAACA,EAAOC,eACV,OAAOF,EAGT,IAAMG,EAAUH,EAAcI,KAAKC,KAAMC,GAAQA,EAAIC,WAAW,6BAAA,CAAA,EAChE9B,GAAO0B,EAAUA,EAAQK,MAAM,GAAA,EAAK,CAAA,EAAK,YAEzC,IAAMC,EAAUT,EAAcI,KAAKC,KAAMC,GAAQA,EAAIC,WAAW,0BAAA,CAAA,EAC5DG,EAAa,GAEjB,GAAID,EACF,CAAA,CAAGC,CAAAA,EAAcD,EAAQD,MAAM,GAAA,UACtBG,QAAQC,IAAIC,2BAMrB,CAAA,CAAGH,CAAAA,EAHWC,QAAQC,IAAIC,2BAA2BL,MAAM,GAAA,EAAKH,KAAMS,GACpEA,EAAKP,WAAW,yBAAA,CAAA,EAEKC,MAAM,GAAA,MAE7B,OAAM,IAAIO,MACR;2FAAA,EAIJrC,OAAAA,GAAOsC,SAASN,EAAY,EAAA,EAErBV,CACT,EApCqC,yBAsCxBiB,GAAgB9D,EAAA,CAAC+D,EAA0BjB,IAAAA,CAEtDiB,EAAG,OAAQ,CACTvB,gBAAAA,EACF,CAAA,EACAuB,EACE,wBACA,CAACnB,EAA0BC,IAAAA,CACzBF,GAAsBC,EAASC,EAAeC,CAAAA,CAChD,CAAA,CAEJ,EAX6B","sourcesContent":["import type { elementNode } from '@chromaui/rrweb-snapshot';\nimport CDP, { Version } from 'chrome-remote-interface';\nimport {\n  ResourceArchiver,\n  writeTestResult,\n  ChromaticStorybookParameters,\n  ResourceArchive,\n  Viewport,\n} from '@chromatic-com/shared-e2e';\n\ninterface CypressSnapshot {\n  // the name of the snapshot (optionally provided for manual snapshots, never provided for automatic snapshots)\n  name?: string;\n  // the DOM snapshot\n  snapshot: elementNode;\n}\n\ninterface WriteParams {\n  testTitlePath: string[];\n  domSnapshots: CypressSnapshot[];\n  chromaticStorybookParams: ChromaticStorybookParameters;\n  pageUrl: string;\n  viewport: Viewport;\n  outputDir: string;\n}\n\ninterface WriteArchivesParams extends WriteParams {\n  resourceArchive: ResourceArchive;\n}\n\nconst writeArchives = async ({\n  testTitlePath,\n  domSnapshots,\n  resourceArchive,\n  chromaticStorybookParams,\n  pageUrl,\n  viewport,\n  outputDir,\n}: WriteArchivesParams) => {\n  const allSnapshots = Object.fromEntries(\n    // manual snapshots can be given a name; otherwise, just use the snapshot's place in line as the name\n    domSnapshots.map(({ name, snapshot }, index) => [\n      name ?? `Snapshot #${index + 1}`,\n      Buffer.from(JSON.stringify(snapshot)),\n    ])\n  );\n\n  await writeTestResult(\n    {\n      titlePath: testTitlePath,\n      outputDir,\n      pageUrl,\n      viewport,\n    },\n    allSnapshots,\n    resourceArchive,\n    chromaticStorybookParams\n  );\n};\n\n// using a single ResourceArchiver instance across all tests (for the test run)\n// each time a test completes, we'll save to disk whatever archives are there at that point.\n// This should be safe since the same resource from the same URL should be the same during the entire test run.\n// Cypress doesn't give us a way to share variables between the \"before test\" and \"after test\" lifecycle events on the server.\nlet resourceArchiver: ResourceArchiver = null;\n\nlet host = '';\nlet port = 0;\n\nconst setupNetworkListener = async ({\n  allowedDomains,\n}: {\n  allowedDomains?: string[];\n}): Promise<null> => {\n  try {\n    const { webSocketDebuggerUrl } = await Version({\n      host,\n      port,\n    });\n\n    const cdp = await CDP({\n      target: webSocketDebuggerUrl,\n    });\n\n    if (!resourceArchiver) {\n      resourceArchiver = new ResourceArchiver(cdp, allowedDomains);\n      await resourceArchiver.watch();\n    }\n  } catch (err) {\n    console.log('err', err);\n  }\n\n  return null;\n};\n\nconst saveArchives = (archiveInfo: WriteParams) => {\n  return new Promise((resolve) => {\n    // the resourceArchiver's archives come from the server, everything else (DOM snapshots, test info, etc) comes from the browser\n    // notice we're not calling + awaiting resourceArchiver.idle() here...\n    // that's because in Cypress, cy.visit() waits until all resources have loaded before finishing\n    // so at this point (after the test) we're confident that the resources are all there already without having to wait more\n    return writeArchives({ ...archiveInfo, resourceArchive: resourceArchiver.archive }).then(() => {\n      resolve(null);\n    });\n  });\n};\n\ninterface TaskParams {\n  action: 'setup-network-listener' | 'save-archives';\n  payload?: any;\n}\n\n// Handles all server-side tasks, dispatching each to its proper handler.\n// Why? So users don't have to register all these individual tasks\n// (they can just import and register prepareArchives)\nexport const prepareArchives = async ({ action, payload }: TaskParams) => {\n  switch (action) {\n    case 'setup-network-listener':\n      return setupNetworkListener(payload);\n    case 'save-archives':\n      return saveArchives(payload);\n    default:\n      return null;\n  }\n};\n\n// We use this lifecycle hook because we need to know what host and port Chrome Devtools Protocol is listening at.\nexport const onBeforeBrowserLaunch = (\n  // we don't use the browser parameter but we're keeping it here in case we'd ever need to read from it\n  // (this way users wouldn't have to change their cypress.config file as it's already passed to us)\n  browser: Cypress.Browser,\n  launchOptions: Cypress.BeforeBrowserLaunchOptions,\n  config: Cypress.PluginConfigOptions\n) => {\n  // don't take snapshots when running `cypress open`\n  if (!config.isTextTerminal) {\n    return launchOptions;\n  }\n\n  const hostArg = launchOptions.args.find((arg) => arg.startsWith('--remote-debugging-address='));\n  host = hostArg ? hostArg.split('=')[1] : '127.0.0.1';\n\n  const portArg = launchOptions.args.find((arg) => arg.startsWith('--remote-debugging-port='));\n  let portString = '';\n\n  if (portArg) {\n    [, portString] = portArg.split('=');\n  } else if (process.env.ELECTRON_EXTRA_LAUNCH_ARGS) {\n    // Electron doesn't pass along the address and port in the launch options, so we need to read the port from the\n    // environment variable that we'll require the user to use (this assumes the host will be 127.0.0.1).\n    const entry = process.env.ELECTRON_EXTRA_LAUNCH_ARGS.split(' ').find((item) =>\n      item.startsWith('--remote-debugging-port')\n    );\n    [, portString] = entry.split('=');\n  } else {\n    throw new Error(\n      'Please provide a port number \\nExample: ELECTRON_EXTRA_LAUNCH_ARGS=--remote-debugging-port=<port-number> yarn cypress run'\n    );\n  }\n\n  port = parseInt(portString, 10);\n\n  return launchOptions;\n};\n\nexport const installPlugin = (on: Cypress.PluginEvents, config: Cypress.PluginConfigOptions) => {\n  // these events are run on the server (in Node)\n  on('task', {\n    prepareArchives,\n  });\n  on(\n    'before:browser:launch',\n    (browser: Cypress.Browser, launchOptions: Cypress.BeforeBrowserLaunchOptions) => {\n      onBeforeBrowserLaunch(browser, launchOptions, config);\n    }\n  );\n};\n"]}