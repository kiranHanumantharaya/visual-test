{"version":3,"sources":["../../../shared/storybook-config/preview.ts"],"names":["NodeType","rebuild","pageUrl","URL","window","location","href","pathname","search","strippedUrl","toString","replace","findHtmlNode","node","type","Element","tagName","childNodes","find","childNode","undefined","snapshotFileName","snapshotId","viewport","fileNameParts","join","fetchSnapshot","context","url","id","storyContext","parameters","server","globals","viewportName","width","height","response","fetch","ok","defaultViewport","json","renderToCanvas","element","snapshot","htmlNode","html","doc","document","replaceChild","children","head","innerHTML","showMain","layout"],"mappings":";;;;AAEA,SAASA,UAAUC,eAAe;AAElC,IAAMC,UAAU,IAAIC,IAAIC,OAAOC,SAASC,IAAI;AAC5CJ,QAAQK,WAAW;AACnBL,QAAQM,SAAS;AACjB,IAAMC,cAAcP,QAAQQ,SAAQ,EAAGC,QAAQ,OAAO,EAAA;AAOtD,IAAMC,eAAe,wBAACC,SAAAA;AACpB,MAAIA,KAAKC,SAASd,SAASe,WAAWF,KAAKG,YAAY,QAAQ;AAC7D,WAAOH;EACT;AAEA,MAAI,gBAAgBA,MAAM;AACxB,WAAOA,KAAKI,WAAWC,KAAK,CAACC,cAAAA;AAC3B,aAAOP,aAAaO,SAAAA;IACtB,CAAA;EACF;AAEA,SAAOC;AACT,GAZqB;AAerB,SAASC,iBAAiBC,YAAoBC,UAAgB;AAC5D,QAAMC,gBAAgB;IAACF;IAAYC;IAAU;;AAC7C,SAAOC,cAAcC,KAAK,GAAA;AAC5B;AAHSJ;AAKT,eAAeK,cAAcC,SAAsC;AACjE,QAAM,EAAEC,KAAKC,GAAE,IAAKF,QAAQG,aAAaC,WAAWC;AACpD,QAAM,EAAET,SAAQ,IAAKI,QAAQG,aAAaG;AAG1C,MAAIC;AACJ,MAAI,OAAOX,aAAa,UAAU;AAChCW,mBAAeX;EACjB,OAAO;AAELW,mBAAe,IAAIX,SAASY,KAAK,IAAIZ,SAASa,MAAM;EACtD;AAEA,MAAIC,WAAW,MAAMC,MAAM,GAAGV,GAAAA,IAAOP,iBAAiBQ,IAAIK,YAAAA,CAAAA,EAAe;AACzE,MAAI,CAACG,SAASE,IAAI;AAGhB,UAAM,EAAEC,gBAAe,IAAKb,QAAQG,aAAaC,WAAWR;AAC5Dc,eAAW,MAAMC,MAAM,GAAGV,GAAAA,IAAOP,iBAAiBQ,IAAIW,eAAAA,CAAAA,EAAkB;EAC1E;AAEA,SAAOH,SAASI,KAAI;AACtB;AAtBef;AAwBf,IAAMgB,iBAAiD,8BAAOf,SAASgB,YAAAA;AACrE,QAAMC,WAAW,MAAMlB,cAAcC,OAAAA;AAGrC,QAAMkB,WAAWjC,aAAagC,QAAAA;AAQ9B,QAAME,OAAQ,MAAM7C,QAAQ4C,UAAU;IAAEE,KAAKC;EAAS,CAAA;AAGtDA,WAASC,aAAaH,MAAME,SAASE,SAAS,CAAA,CAAE;AAOhDF,WAASG,KAAKC,aACZ;AAEFzB,UAAQ0B,SAAQ;AAChB,SAAO,MAAA;EAAO;AAChB,GA3BuD;AA6BvD,IAAA,kBAAe;EACbX;EACAX,YAAY;IACVC,QAAQ;MAAEJ,KAAKnB;IAAY;IAC3B6C,QAAQ;EACV;AACF","sourcesContent":["import type { RenderContext, RenderToCanvas, WebRenderer } from '@storybook/types';\nimport type { serializedNodeWithId } from '@chromaui/rrweb-snapshot';\nimport { NodeType, rebuild } from '@chromaui/rrweb-snapshot';\n\nconst pageUrl = new URL(window.location.href);\npageUrl.pathname = '';\npageUrl.search = '';\nconst strippedUrl = pageUrl.toString().replace(/\\/$/, '');\n\nexport interface RRWebFramework extends WebRenderer {\n  component: undefined;\n  storyResult: Record<string, never>;\n}\n\nconst findHtmlNode = (node: serializedNodeWithId): serializedNodeWithId | undefined => {\n  if (node.type === NodeType.Element && node.tagName === 'html') {\n    return node;\n  }\n\n  if ('childNodes' in node) {\n    return node.childNodes.find((childNode) => {\n      return findHtmlNode(childNode);\n    });\n  }\n\n  return undefined;\n};\n\n// NOTE: This is duplicated in the shared package due to bundling issues\nfunction snapshotFileName(snapshotId: string, viewport: string) {\n  const fileNameParts = [snapshotId, viewport, 'snapshot.json'];\n  return fileNameParts.join('.');\n}\n\nasync function fetchSnapshot(context: RenderContext<RRWebFramework>) {\n  const { url, id } = context.storyContext.parameters.server;\n  const { viewport } = context.storyContext.globals;\n\n  // Viewport seems to be a string or an object\n  let viewportName;\n  if (typeof viewport === 'string') {\n    viewportName = viewport;\n  } else {\n    // NOTE: This is duplicated in the shared package due to bundling issues\n    viewportName = `w${viewport.width}h${viewport.height}`;\n  }\n\n  let response = await fetch(`${url}/${snapshotFileName(id, viewportName)}`);\n  if (!response.ok) {\n    // Possibly a viewport was specified that we haven't captured, or it's the addon's\n    // default of `reset`, so we'll load the default viewport snapshot instead.\n    const { defaultViewport } = context.storyContext.parameters.viewport;\n    response = await fetch(`${url}/${snapshotFileName(id, defaultViewport)}`);\n  }\n\n  return response.json();\n}\n\nconst renderToCanvas: RenderToCanvas<RRWebFramework> = async (context, element) => {\n  const snapshot = await fetchSnapshot(context);\n\n  // The snapshot is a representation of a complete HTML document\n  const htmlNode = findHtmlNode(snapshot);\n\n  // If you rebuild the full snapshot with rrweb (the document) it will replace the\n  // current document and call `document.open()` in the process, which unbinds all event handlers\n  // (and breaks Storybook).\n  // However, if you just rebuild the html element part, it will recreate but not attempt to\n  // insert it in the DOM.\n  // @ts-expect-error rebuild is typed incorreclty, cache and mirror are optional\n  const html = (await rebuild(htmlNode, { doc: document })) as HTMLElement;\n\n  // Now we insert the rebuilt html element in the DOM\n  document.replaceChild(html, document.children[0]);\n\n  // Storybook's WebView will throw an error if it cannot find these two ids in the DOM.\n  // We never render docs (so the #storybook-docs doesn't matter), and our`renderToCanvas`\n  // function is already ignoring the #storybook-root (`element` above), so it doesn't matter where\n  // they are or what they contain.\n  // We make them a script in the head to ensure they don't impact layout.\n  document.head.innerHTML +=\n    '<script id=\"storybook-root\"></script><script id=\"storybook-docs\"></script>';\n\n  context.showMain();\n  return () => {}; // We can't really cleanup\n};\n\nexport default {\n  renderToCanvas,\n  parameters: {\n    server: { url: strippedUrl },\n    layout: 'fullscreen',\n  },\n};\n"]}